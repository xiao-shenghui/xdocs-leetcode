# LeetCode
> 一个适合前端工程师，从 0 学习算法的文档。    
> 参考至 [leetcode-javascript](https://github.com/sl1673495/leetcode-javascript), 对齐进行排序，整理和学习。  
> 以下内容按`类型优先`，`题序其次`的原则排序。  

## 动态规划
> 包含题目:  
> `最长回文子串-5`，`括号生成-22`，`最小路径和-64`，`爬楼梯-70`，`解码方法-91`,  
> `三角形最小路径和-120`，`买卖股票的最佳时机-121`，`单词拆分-139`，`最大正方形-221`，   
> `最长上升子序列-300`，`摆动序列-376`，`无重叠区间-435`，`一和零-474`，`目标和-494`，`最长重复子数组-718`，  
> `最长的斐波那契子序列的长度-873`, `下降路径最小和-931`，`最长等差数列-1027`，`最长公共子序列-1143`， 

### 最长回文子串-5
- **难度**： 中等
- **题目**： 
给你一个`字符串s`，找到 `s` 中`最长的`回文子串。  
如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
- **示例 1**：
```html
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```
- **示例 2**：
```html
输入：s = "cbbd"
输出："bb"
```
- **提示**：
	- 1 <= s.length <= 1000
	- s 仅由数字和英文字母组成

- **解题思路**
```js
var longestPalindrome = function(s) {
    // 1.回文字符的要求： >= 1个字符，连续的字符
    // 2.判断回文字符是否在字符串内
    // 3.判断最长的回文子串
    
    // 解题思路：
    // 暴力法: 
    // 由长度为n = length-1开始，取连续的n个reverse()之后，判断是否includes()
    // 例如"babad", n = 4, 取"baba",失败，取"abad"失败，到末尾了。
    // 然后 n = 3，取"bab",成功。 出结果。

    // 中心扩散法： 利用回文的两端相等特性, 以及对称性
    // 找一个起始点i，利用：i--, j = ++i往两边同时扩散，
    // 如果s[i] == s[j], 那么它就是回文。
    // 这里要分偶数和奇数回文，
    // 偶数起始点要有两个，i和i+1。 j = i+1+1

    // 此时回文结果为 str.substr(s[i],len) (len就是i和j的距离)
    // 直到i从0边界，扩散到了末尾边界。
};
```
- **解题**
```js
var longestPalindrome = function(s) {
	let len = 0;
    let start = 0;
    for(let i = 1; i<s.length-1; i++){
        // 奇数回文
        check(i,i)
        // 偶数回文
        check(i,i+1)
    }

    // 回文方法
    function check(i,j){
    	// s[i] == s[j]两端相等
        while (i >= 0 && j < s.length-1 && s[i] == s[j]) {
        	// 只要扩散以后的间距，大于上一次间距，就表示出现了更长的回文。
            if (j - i + 1 > len) {
                start = i;
                len = j - i + 1;
            }
            // 对称性：两端同步扩展，一直扩展到边界为止
            i--;
            j++;
        }
    }
    return s.substr(start, len)
}
```

